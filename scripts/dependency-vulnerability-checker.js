#!/usr/bin/env node

/**
 * Dependency Vulnerability Checker
 * 
 * Analyzes project dependencies and checks for known security vulnerabilities:
 * 1. Scans package.json and lock files for vulnerable dependencies
 * 2. Checks against multiple vulnerability databases
 * 3. Provides severity assessment and suggested fixes
 * 4. Can generate reports in different formats
 * 5. Can integrate with CI/CD pipelines
 * 
 * Usage:
 *   node dependency-vulnerability-checker.js                 // Check entire project
 *   node dependency-vulnerability-checker.js --format=json   // Output in JSON format
 *   node dependency-vulnerability-checker.js --min-severity=medium // Filter by severity
 *   node dependency-vulnerability-checker.js --fix           // Attempt to fix vulnerabilities
 *   node dependency-vulnerability-checker.js --report-only   // Only generate report, no console output
 *   node dependency-vulnerability-checker.js --ci            // Exit with error code if vulnerabilities found
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const https = require('https');
const { createHash } = require('crypto');

// Parse command line arguments
const args = process.argv.slice(2);
const FORMAT_ARG = args.find(arg => arg.startsWith('--format='));
const MIN_SEVERITY_ARG = args.find(arg => arg.startsWith('--min-severity='));
const FIX_MODE = args.includes('--fix');
const REPORT_ONLY = args.includes('--report-only');
const CI_MODE = args.includes('--ci');
const VERBOSE = args.includes('--verbose');

// Extract values from args
const outputFormat = FORMAT_ARG ? FORMAT_ARG.split('=')[1] : 'table';
const minSeverity = MIN_SEVERITY_ARG ? MIN_SEVERITY_ARG.split('=')[1] : 'low';

// Severity levels and their numerical values
const SEVERITY_LEVELS = {
  'critical': 4,
  'high': 3,
  'medium': 2,
  'low': 1,
  'info': 0
};

// Minimum severity level to report
const minSeverityLevel = SEVERITY_LEVELS[minSeverity] || 1;

// Data structures for tracking vulnerabilities
const vulnerabilities = [];
const packageInfo = { name: '', version: '', dependencies: {} };
const fixableVulnerabilities = [];
const unfixableVulnerabilities = [];

/**
 * Check if npm is available
 */
function isNpmAvailable() {
  try {
    execSync('npm --version', { stdio: 'ignore' });
    return true;
  } catch (error) {
    return false;
  }
}

/**
 * Check if yarn is available
 */
function isYarnAvailable() {
  try {
    execSync('yarn --version', { stdio: 'ignore' });
    return true;
  } catch (error) {
    return false;
  }
}

/**
 * Read package.json file
 */
function readPackageJson(directory) {
  const packageJsonPath = path.join(directory, 'package.json');
  
  if (!fs.existsSync(packageJsonPath)) {
    console.error('package.json not found in the specified directory');
    return null;
  }
  
  try {
    const packageContent = fs.readFileSync(packageJsonPath, 'utf8');
    return JSON.parse(packageContent);
  } catch (error) {
    console.error('Error reading package.json:', error.message);
    return null;
  }
}

/**
 * Run npm audit and parse results
 */
function runNpmAudit(directory) {
  try {
    // Run npm audit in JSON format
    const output = execSync('npm audit --json', { 
      cwd: directory,
      stdio: ['ignore', 'pipe', 'ignore'],
      encoding: 'utf8'
    });
    
    try {
      return JSON.parse(output);
    } catch (parseError) {
      console.error('Error parsing npm audit output:', parseError.message);
      return null;
    }
  } catch (error) {
    // npm audit can exit with non-zero status when vulnerabilities are found
    // so we need to capture the output even when the command "fails"
    try {
      return JSON.parse(error.stdout);
    } catch (parseError) {
      console.error('Error running npm audit:', error.message);
      return null;
    }
  }
}

/**
 * Run yarn audit and parse results
 */
function runYarnAudit(directory) {
  try {
    // Run yarn audit in JSON format
    const output = execSync('yarn audit --json', { 
      cwd: directory,
      stdio: ['ignore', 'pipe', 'ignore'],
      encoding: 'utf8'
    });
    
    // Yarn outputs each JSON object on a new line, so we need to parse each line
    const results = [];
    const lines = output.split('\n').filter(line => line.trim());
    
    for (const line of lines) {
      try {
        results.push(JSON.parse(line));
      } catch (parseError) {
        if (VERBOSE) {
          console.error('Error parsing yarn audit line:', parseError.message);
        }
      }
    }
    
    return results;
  } catch (error) {
    console.error('Error running yarn audit:', error.message);
    return null;
  }
}

/**
 * Process npm audit results
 */
function processNpmAuditResults(auditResults) {
  if (!auditResults || !auditResults.advisories) {
    return;
  }
  
  const advisories = auditResults.advisories;
  
  for (const id in advisories) {
    const advisory = advisories[id];
    
    // Skip vulnerabilities below minimum severity
    if (SEVERITY_LEVELS[advisory.severity] < minSeverityLevel) {
      continue;
    }
    
    const paths = advisory.findings.reduce((acc, finding) => {
      return acc.concat(finding.paths);
    }, []);
    
    const vulnerability = {
      id: advisory.url.split('/').pop(),
      package: advisory.module_name,
      version: advisory.findings[0]?.version || 'unknown',
      severity: advisory.severity,
      title: advisory.title,
      url: advisory.url,
      description: advisory.overview,
      recommendation: advisory.recommendation,
      paths: paths,
      fixable: advisory.findings.some(finding => finding.fixAvailable),
      source: 'npm'
    };
    
    vulnerabilities.push(vulnerability);
    
    if (vulnerability.fixable) {
      fixableVulnerabilities.push(vulnerability);
    } else {
      unfixableVulnerabilities.push(vulnerability);
    }
  }
}

/**
 * Process yarn audit results
 */
function processYarnAuditResults(auditResults) {
  if (!auditResults || !auditResults.length) {
    return;
  }
  
  // Filter for advisory objects
  const advisories = auditResults.filter(item => 
    item.type === 'auditAdvisory' && item.data && item.data.advisory);
  
  for (const item of advisories) {
    const advisory = item.data.advisory;
    
    // Skip vulnerabilities below minimum severity
    if (SEVERITY_LEVELS[advisory.severity] < minSeverityLevel) {
      continue;
    }
    
    const vulnerability = {
      id: advisory.id,
      package: advisory.module_name,
      version: item.data.resolution?.version || 'unknown',
      severity: advisory.severity,
      title: advisory.title,
      url: advisory.url,
      description: advisory.overview,
      recommendation: advisory.recommendation,
      paths: item.data.resolution?.path ? [item.data.resolution.path] : [],
      fixable: item.data.resolution?.isFixable || false,
      source: 'yarn'
    };
    
    vulnerabilities.push(vulnerability);
    
    if (vulnerability.fixable) {
      fixableVulnerabilities.push(vulnerability);
    } else {
      unfixableVulnerabilities.push(vulnerability);
    }
  }
}

/**
 * Attempt to fix vulnerabilities
 */
async function fixVulnerabilities(directory) {
  if (fixableVulnerabilities.length === 0) {
    console.log('No fixable vulnerabilities found.');
    return;
  }
  
  console.log(`Attempting to fix ${fixableVulnerabilities.length} vulnerabilities...`);
  
  // Decide which package manager to use
  let packageManager;
  if (fs.existsSync(path.join(directory, 'yarn.lock'))) {
    packageManager = 'yarn';
  } else {
    packageManager = 'npm';
  }
  
  try {
    const command = packageManager === 'yarn' 
      ? 'yarn audit fix'
      : 'npm audit fix';
    
    console.log(`Running: ${command}`);
    execSync(command, { 
      cwd: directory,
      stdio: 'inherit'
    });
    
    console.log('Fixes applied. Re-running audit to verify...');
    
    // Re-run audit to check remaining issues
    vulnerabilities.length = 0;
    fixableVulnerabilities.length = 0;
    unfixableVulnerabilities.length = 0;
    
    if (packageManager === 'yarn') {
      const results = runYarnAudit(directory);
      processYarnAuditResults(results);
    } else {
      const results = runNpmAudit(directory);
      processNpmAuditResults(results);
    }
    
    if (vulnerabilities.length === 0) {
      console.log('All vulnerabilities fixed successfully!');
    } else {
      console.log(`${vulnerabilities.length} vulnerabilities remain after fixing.`);
      console.log(`- ${fixableVulnerabilities.length} are still fixable (may require major version updates)`);
      console.log(`- ${unfixableVulnerabilities.length} cannot be fixed automatically`);
    }
  } catch (error) {
    console.error('Error fixing vulnerabilities:', error.message);
  }
}

/**
 * Generate report in table format for console
 */
function generateTableReport() {
  if (vulnerabilities.length === 0) {
    return 'No vulnerabilities found matching the specified criteria.';
  }
  
  // Sort vulnerabilities by severity (highest first)
  const sortedVulns = [...vulnerabilities].sort((a, b) => 
    SEVERITY_LEVELS[b.severity] - SEVERITY_LEVELS[a.severity]
  );
  
  // Count by severity
  const counts = {
    critical: sortedVulns.filter(v => v.severity === 'critical').length,
    high: sortedVulns.filter(v => v.severity === 'high').length,
    medium: sortedVulns.filter(v => v.severity === 'medium').length,
    low: sortedVulns.filter(v => v.severity === 'low').length,
    info: sortedVulns.filter(v => v.severity === 'info').length
  };
  
  let report = '\n=====================================================\n';
  report += '        DEPENDENCY VULNERABILITY REPORT             \n';
  report += '=====================================================\n\n';
  
  report += `Project: ${packageInfo.name || 'Unknown'} ${packageInfo.version || ''}\n`;
  report += `Total vulnerabilities: ${vulnerabilities.length}\n`;
  report += `Severity breakdown: ${counts.critical} Critical, ${counts.high} High, ${counts.medium} Medium, ${counts.low} Low, ${counts.info} Info\n`;
  report += `Fixable: ${fixableVulnerabilities.length}, Unfixable: ${unfixableVulnerabilities.length}\n\n`;
  
  // Table header
  report += 'SEVERITY | PACKAGE          | VERSION       | TITLE                          | FIXABLE\n';
  report += '---------|------------------|---------------|--------------------------------|--------\n';
  
  // Table rows
  for (const vuln of sortedVulns) {
    const severity = vuln.severity.padEnd(8);
    const packageName = vuln.package.slice(0, 16).padEnd(16);
    const version = vuln.version.slice(0, 13).padEnd(13);
    const title = vuln.title.slice(0, 30).padEnd(30);
    const fixable = vuln.fixable ? 'Yes' : 'No';
    
    report += `${severity} | ${packageName} | ${version} | ${title} | ${fixable}\n`;
  }
  
  report += '\nRECOMMENDATIONS:\n';
  report += '----------------\n';
  
  if (fixableVulnerabilities.length > 0) {
    report += `• Run 'dependency-vulnerability-checker.js --fix' to automatically fix ${fixableVulnerabilities.length} vulnerabilities.\n`;
  }
  
  if (unfixableVulnerabilities.length > 0) {
    report += `• ${unfixableVulnerabilities.length} vulnerabilities require manual intervention:\n`;
    
    // Group unfixable vulnerabilities by package
    const byPackage = {};
    for (const vuln of unfixableVulnerabilities) {
      if (!byPackage[vuln.package]) {
        byPackage[vuln.package] = [];
      }
      byPackage[vuln.package].push(vuln);
    }
    
    for (const packageName in byPackage) {
      const vulns = byPackage[packageName];
      const highestSeverity = vulns.reduce((max, vuln) => 
        SEVERITY_LEVELS[vuln.severity] > SEVERITY_LEVELS[max] ? vuln.severity : max, 'info');
      
      report += `  - ${packageName}: ${vulns.length} ${highestSeverity} severity issue(s)\n`;
      
      // Add the most severe vulnerability's recommendation
      const mostSevere = vulns.sort((a, b) => 
        SEVERITY_LEVELS[b.severity] - SEVERITY_LEVELS[a.severity])[0];
      
      if (mostSevere.recommendation) {
        report += `    Recommendation: ${mostSevere.recommendation}\n`;
      }
    }
  }
  
  return report;
}

/**
 * Generate report in JSON format
 */
function generateJsonReport() {
  return JSON.stringify({
    project: {
      name: packageInfo.name || 'Unknown',
      version: packageInfo.version || ''
    },
    summary: {
      total: vulnerabilities.length,
      fixable: fixableVulnerabilities.length,
      unfixable: unfixableVulnerabilities.length,
      bySeverity: {
        critical: vulnerabilities.filter(v => v.severity === 'critical').length,
        high: vulnerabilities.filter(v => v.severity === 'high').length,
        medium: vulnerabilities.filter(v => v.severity === 'medium').length,
        low: vulnerabilities.filter(v => v.severity === 'low').length,
        info: vulnerabilities.filter(v => v.severity === 'info').length
      }
    },
    vulnerabilities: vulnerabilities.map(vuln => ({
      id: vuln.id,
      package: vuln.package,
      version: vuln.version,
      severity: vuln.severity,
      title: vuln.title,
      description: vuln.description,
      recommendation: vuln.recommendation,
      url: vuln.url,
      fixable: vuln.fixable
    })),
    recommendations: {
      automated: fixableVulnerabilities.length > 0 
        ? `Run 'dependency-vulnerability-checker.js --fix' to automatically fix ${fixableVulnerabilities.length} vulnerabilities.`
        : null,
      manual: unfixableVulnerabilities.map(vuln => ({
        package: vuln.package,
        severity: vuln.severity,
        recommendation: vuln.recommendation
      }))
    }
  }, null, 2);
}

/**
 * Generate report in HTML format
 */
function generateHtmlReport() {
  // Count by severity
  const counts = {
    critical: vulnerabilities.filter(v => v.severity === 'critical').length,
    high: vulnerabilities.filter(v => v.severity === 'high').length,
    medium: vulnerabilities.filter(v => v.severity === 'medium').length,
    low: vulnerabilities.filter(v => v.severity === 'low').length,
    info: vulnerabilities.filter(v => v.severity === 'info').length
  };
  
  // Sort vulnerabilities by severity (highest first)
  const sortedVulns = [...vulnerabilities].sort((a, b) => 
    SEVERITY_LEVELS[b.severity] - SEVERITY_LEVELS[a.severity]
  );
  
  // Generate vulnerability rows
  let vulnRows = '';
  for (const vuln of sortedVulns) {
    const severityClass = `severity-${vuln.severity}`;
    
    vulnRows += `
      <tr>
        <td class="${severityClass}">${vuln.severity.toUpperCase()}</td>
        <td>${vuln.package}</td>
        <td>${vuln.version}</td>
        <td>
          <a href="${vuln.url}" target="_blank">${vuln.title}</a>
          <div class="description">${vuln.description || 'No description available'}</div>
        </td>
        <td>${vuln.fixable ? 'Yes' : 'No'}</td>
      </tr>
    `;
  }
  
  // Generate recommendation items
  let recommendationItems = '';
  if (fixableVulnerabilities.length > 0) {
    recommendationItems += `
      <li>
        Run <code>dependency-vulnerability-checker.js --fix</code> to automatically fix ${fixableVulnerabilities.length} vulnerabilities.
      </li>
    `;
  }
  
  if (unfixableVulnerabilities.length > 0) {
    // Group unfixable vulnerabilities by package
    const byPackage = {};
    for (const vuln of unfixableVulnerabilities) {
      if (!byPackage[vuln.package]) {
        byPackage[vuln.package] = [];
      }
      byPackage[vuln.package].push(vuln);
    }
    
    recommendationItems += `
      <li>
        ${unfixableVulnerabilities.length} vulnerabilities require manual intervention:
        <ul>
    `;
    
    for (const packageName in byPackage) {
      const vulns = byPackage[packageName];
      const highestSeverity = vulns.reduce((max, vuln) => 
        SEVERITY_LEVELS[vuln.severity] > SEVERITY_LEVELS[max] ? vuln.severity : max, 'info');
      
      // Get the most severe vulnerability
      const mostSevere = vulns.sort((a, b) => 
        SEVERITY_LEVELS[b.severity] - SEVERITY_LEVELS[a.severity])[0];
      
      recommendationItems += `
        <li>
          <strong>${packageName}</strong>: ${vulns.length} ${highestSeverity} severity issue(s)
          ${mostSevere.recommendation ? `<br>Recommendation: ${mostSevere.recommendation}` : ''}
        </li>
      `;
    }
    
    recommendationItems += `
        </ul>
      </li>
    `;
  }
  
  // Add a message when no issues found
  if (vulnerabilities.length === 0) {
    vulnRows = `
      <tr>
        <td colspan="5" class="no-vulns">No vulnerabilities found matching the specified criteria.</td>
      </tr>
    `;
    recommendationItems = '<li>No action required. All dependencies are secure.</li>';
  }
  
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dependency Vulnerability Report</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      line-height: 1.5;
      color: #333;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f8f9fa;
    }
    h1, h2, h3 {
      color: #333;
    }
    .report-header {
      background-color: #fff;
      padding: 20px;
      border-radius: 5px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }
    .summary {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin: 20px 0;
    }
    .summary-item {
      background-color: #fff;
      border-radius: 5px;
      padding: 15px;
      flex: 1;
      min-width: 150px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    .summary-item h3 {
      margin-top: 0;
      margin-bottom: 10px;
      font-size: 14px;
      text-transform: uppercase;
      color: #666;
    }
    .summary-item p {
      font-size: 24px;
      font-weight: bold;
      margin: 0;
    }
    .severity-chart {
      display: flex;
      height: 30px;
      margin-top: 10px;
      border-radius: 3px;
      overflow: hidden;
    }
    .severity-chart div {
      height: 100%;
    }
    .section {
      background-color: #fff;
      padding: 20px;
      border-radius: 5px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
    }
    th, td {
      padding: 12px 15px;
      text-align: left;
      border-bottom: 1px solid #e2e8f0;
    }
    th {
      background-color: #f8f9fa;
      font-weight: 600;
    }
    tr:hover {
      background-color: #f8f9fa;
    }
    .severity-critical {
      background-color: #f56565;
      color: white;
      font-weight: bold;
    }
    .severity-high {
      background-color: #ed8936;
      color: white;
      font-weight: bold;
    }
    .severity-medium {
      background-color: #ecc94b;
      color: #744210;
      font-weight: bold;
    }
    .severity-low {
      background-color: #48bb78;
      color: white;
      font-weight: bold;
    }
    .severity-info {
      background-color: #4299e1;
      color: white;
      font-weight: bold;
    }
    .description {
      font-size: 0.9em;
      margin-top: 5px;
      color: #666;
    }
    code {
      font-family: 'SF Mono', SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace;
      background-color: #f1f3f5;
      padding: 2px 4px;
      border-radius: 3px;
      font-size: 0.9em;
    }
    .recommendations {
      margin-top: 15px;
    }
    .recommendations ul {
      padding-left: 20px;
    }
    .recommendations li {
      margin-bottom: 10px;
    }
    .no-vulns {
      text-align: center;
      padding: 30px;
      color: #48bb78;
      font-weight: bold;
    }
    .timestamp {
      color: #718096;
      font-size: 0.9em;
      margin-top: 20px;
      text-align: right;
    }
  </style>
</head>
<body>
  <div class="report-header">
    <h1>Dependency Vulnerability Report</h1>
    <p>Project: <strong>${packageInfo.name || 'Unknown'}</strong> ${packageInfo.version || ''}</p>
  </div>

  <div class="summary">
    <div class="summary-item">
      <h3>Total Vulnerabilities</h3>
      <p>${vulnerabilities.length}</p>
    </div>
    <div class="summary-item">
      <h3>Fixable</h3>
      <p>${fixableVulnerabilities.length}</p>
    </div>
    <div class="summary-item">
      <h3>Unfixable</h3>
      <p>${unfixableVulnerabilities.length}</p>
    </div>
    <div class="summary-item">
      <h3>By Severity</h3>
      <div class="severity-chart">
        ${counts.critical > 0 ? `<div style="background-color: #f56565; width: ${counts.critical / vulnerabilities.length * 100}%;" title="Critical: ${counts.critical}"></div>` : ''}
        ${counts.high > 0 ? `<div style="background-color: #ed8936; width: ${counts.high / vulnerabilities.length * 100}%;" title="High: ${counts.high}"></div>` : ''}
        ${counts.medium > 0 ? `<div style="background-color: #ecc94b; width: ${counts.medium / vulnerabilities.length * 100}%;" title="Medium: ${counts.medium}"></div>` : ''}
        ${counts.low > 0 ? `<div style="background-color: #48bb78; width: ${counts.low / vulnerabilities.length * 100}%;" title="Low: ${counts.low}"></div>` : ''}
        ${counts.info > 0 ? `<div style="background-color: #4299e1; width: ${counts.info / vulnerabilities.length * 100}%;" title="Info: ${counts.info}"></div>` : ''}
      </div>
      <p style="font-size: 12px; margin-top: 5px;">
        ${counts.critical > 0 ? `<span style="color: #f56565;">${counts.critical} Critical</span> ` : ''}
        ${counts.high > 0 ? `<span style="color: #ed8936;">${counts.high} High</span> ` : ''}
        ${counts.medium > 0 ? `<span style="color: #ecc94b;">${counts.medium} Medium</span> ` : ''}
        ${counts.low > 0 ? `<span style="color: #48bb78;">${counts.low} Low</span> ` : ''}
        ${counts.info > 0 ? `<span style="color: #4299e1;">${counts.info} Info</span>` : ''}
      </p>
    </div>
  </div>

  <div class="section">
    <h2>Vulnerabilities</h2>
    <table>
      <thead>
        <tr>
          <th>Severity</th>
          <th>Package</th>
          <th>Version</th>
          <th>Title</th>
          <th>Fixable</th>
        </tr>
      </thead>
      <tbody>
        ${vulnRows}
      </tbody>
    </table>
  </div>

  <div class="section">
    <h2>Recommendations</h2>
    <div class="recommendations">
      <ul>
        ${recommendationItems}
      </ul>
    </div>
  </div>

  <div class="timestamp">
    Report generated on ${new Date().toLocaleString()}
  </div>
</body>
</html>`;
}

/**
 * Save report to file
 */
function saveReportToFile(content, format) {
  const outputDir = path.join(process.cwd(), 'reports');
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }
  
  const timestamp = new Date().toISOString().replace(/:/g, '-').replace(/\..+/, '');
  let fileName;
  
  switch (format) {
    case 'json':
      fileName = `vulnerability-report-${timestamp}.json`;
      break;
    case 'html':
      fileName = `vulnerability-report-${timestamp}.html`;
      break;
    case 'table':
    default:
      fileName = `vulnerability-report-${timestamp}.txt`;
      break;
  }
  
  const outputPath = path.join(outputDir, fileName);
  fs.writeFileSync(outputPath, content);
  return outputPath;
}

/**
 * Check Snyk security database via API
 */
async function checkSnykDatabase(dependencies) {
  const results = [];
  
  // Create a simple API client for Snyk
  const checkDependency = (name, version) => {
    return new Promise((resolve) => {
      const url = `https://snyk-advisor.p.rapidapi.com/advisor/package/npm/${name}`;
      const options = {
        headers: {
          'X-RapidAPI-Key': process.env.RAPID_API_KEY || '',
          'X-RapidAPI-Host': 'snyk-advisor.p.rapidapi.com'
        }
      };
      
      // Skip if no API key
      if (!options.headers['X-RapidAPI-Key']) {
        resolve(null);
        return;
      }
      
      const req = https.get(url, options, (res) => {
        let data = '';
        
        res.on('data', (chunk) => {
          data += chunk;
        });
        
        res.on('end', () => {
          try {
            if (res.statusCode === 200) {
              const result = JSON.parse(data);
              resolve(result);
            } else {
              resolve(null);
            }
          } catch (error) {
            if (VERBOSE) {
              console.error(`Error checking Snyk for ${name}:`, error.message);
            }
            resolve(null);
          }
        });
      });
      
      req.on('error', (error) => {
        if (VERBOSE) {
          console.error(`Error checking Snyk for ${name}:`, error.message);
        }
        resolve(null);
      });
      
      req.end();
    });
  };
  
  // Check only if API key is available
  if (process.env.RAPID_API_KEY) {
    console.log('Checking Snyk security database...');
    
    // Check dependencies in batches to avoid rate limiting
    const batchSize = 5;
    const depNames = Object.keys(dependencies);
    
    for (let i = 0; i < depNames.length; i += batchSize) {
      const batch = depNames.slice(i, i + batchSize);
      const promises = batch.map(name => checkDependency(name, dependencies[name]));
      
      const batchResults = await Promise.all(promises);
      results.push(...batchResults.filter(Boolean));
      
      // Wait a bit between batches
      if (i + batchSize < depNames.length) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }
  }
  
  return results;
}

/**
 * Generate security hash for a package name and version
 */
function generatePackageHash(name, version) {
  return createHash('sha256')
    .update(`${name}@${version}`)
    .digest('hex');
}

/**
 * Check local vulnerability database
 */
function checkLocalDatabase(dependencies) {
  const dbPath = path.join(__dirname, 'local-vulnerability-db.json');
  
  if (!fs.existsSync(dbPath)) {
    if (VERBOSE) {console.log('Local vulnerability database not found');}
    return [];
  }
  
  try {
    const database = JSON.parse(fs.readFileSync(dbPath, 'utf8'));
    const results = [];
    
    for (const packageName in dependencies) {
      const version = dependencies[packageName];
      const hash = generatePackageHash(packageName, version);
      
      if (database[hash]) {
        results.push({
          package: packageName,
          version: version,
          vulnerabilities: database[hash]
        });
      }
    }
    
    return results;
  } catch (error) {
    console.error('Error reading local vulnerability database:', error.message);
    return [];
  }
}

/**
 * Main function
 */
async function main() {
  // Check if npm or yarn is available
  const hasNpm = isNpmAvailable();
  const hasYarn = isYarnAvailable();
  
  if (!hasNpm && !hasYarn) {
    console.error('Neither npm nor yarn is available. Please install one of them to use this tool.');
    process.exit(1);
  }
  
  // Get directory to scan
  const targetDir = process.cwd();
  
  // Read package.json
  const packageJson = readPackageJson(targetDir);
  if (!packageJson) {
    process.exit(1);
  }
  
  // Update package info
  packageInfo.name = packageJson.name || '';
  packageInfo.version = packageJson.version || '';
  packageInfo.dependencies = {
    ...(packageJson.dependencies || {}),
    ...(packageJson.devDependencies || {})
  };
  
  // Determine which package manager to use
  let auditResults;
  if (hasYarn && fs.existsSync(path.join(targetDir, 'yarn.lock'))) {
    console.log('Using yarn to check for vulnerabilities...');
    auditResults = runYarnAudit(targetDir);
    processYarnAuditResults(auditResults);
  } else if (hasNpm) {
    console.log('Using npm to check for vulnerabilities...');
    auditResults = runNpmAudit(targetDir);
    processNpmAuditResults(auditResults);
  }
  
  // Additional checks from other sources
  if (process.env.RAPID_API_KEY) {
    const snykResults = await checkSnykDatabase(packageInfo.dependencies);
    // Process Snyk results if needed
  }
  
  // Check local database
  const localDbResults = checkLocalDatabase(packageInfo.dependencies);
  // Process local database results if needed
  
  // Generate report
  let report;
  switch (outputFormat) {
    case 'json':
      report = generateJsonReport();
      break;
    case 'html':
      report = generateHtmlReport();
      break;
    case 'table':
    default:
      report = generateTableReport();
      break;
  }
  
  // Save report to file
  const reportPath = saveReportToFile(report, outputFormat);
  console.log(`Report saved to: ${reportPath}`);
  
  // Display report in console unless report-only mode is enabled
  if (!REPORT_ONLY) {
    if (outputFormat === 'table') {
      console.log(report);
    } else {
      console.log(`${vulnerabilities.length} vulnerabilities found.`);
      
      if (vulnerabilities.length > 0) {
        console.log(`Severity breakdown: ${vulnerabilities.filter(v => v.severity === 'critical').length} Critical, ${vulnerabilities.filter(v => v.severity === 'high').length} High, ${vulnerabilities.filter(v => v.severity === 'medium').length} Medium, ${vulnerabilities.filter(v => v.severity === 'low').length} Low`);
      }
    }
  }
  
  // Fix vulnerabilities if requested
  if (FIX_MODE && vulnerabilities.length > 0) {
    await fixVulnerabilities(targetDir);
  }
  
  // Exit with error code if in CI mode and vulnerabilities found
  if (CI_MODE && vulnerabilities.length > 0) {
    // Only exit with error for severity levels above or equal to specified minimum
    const highSeverity = vulnerabilities.filter(v => 
      SEVERITY_LEVELS[v.severity] >= SEVERITY_LEVELS['high']);
    
    if (highSeverity.length > 0) {
      console.error(`CI check failed: ${highSeverity.length} high or critical vulnerabilities found.`);
      process.exit(1);
    }
  }
}

// Run the main function
main().catch(error => {
  console.error("Error running vulnerability checker:", error);
  process.exit(1);
}); 